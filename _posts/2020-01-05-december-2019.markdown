---
layout: post
title:  "Декабрь 2019"
categories: django encryption
---

1. <a href='#how-to-encode-and-crypt-data'>Способы передачи данных используя кодирование и шифрование</a>
1. <a href='#xpath-usage'>Возможности XPath</a>
1. <a href='#update-via-tmp-table'>Обновление данных через tmp таблицу</a>
1. <a href='#vpn-attempts'>Vpn - страдания и радости</a>

### <a name='how-to-encode-and-crypt-data'>Способы передачи данных используя кодирование и шифрование</a>

Как передаются данных между сервисами api и т.д.? Задался я таким вопросом.
 

Для себя я выделил несколько вопросов и объединил их в несколько по преследуемой цели их использования

#### 1. Кодирование в base64.

Причины передачи данных в **base64**:

  1. Кодирование нужно, чтобы не передавать бинарные данные в сыром виде. Потому что например в вашем json будет лежать
`\r\n` символ, и при передаче через http-протокол эта последовательность байт будет воспринята как управляющие символы.
Поэтому для безопасной передачи бинарных данных их кодируют в base64.
  2. Данные после кодирования будут представлены в ascii коде, что может избежать проблем при его выводе не поддерживающим unicode.


Стоит отметить, что кодировать можно и в base32 и base16, но тогда длина результата увеличится из-за уменьшения диапазона символов.


_Кроме этого_.


В django. есть модуль `django.utils.baseconv` который преобразует число в base64, base32 и до base2.
При этом base64 работает алфавит не такой же как в base64.encode() `-_` _vs_ `+/` 

```python

import base64

data = {
    'last_name': 'Vlasov',
    'first_name': 'Sergey',
    'age': '28',
    'address': {
        'city': 'Серпухов',
        'street': 'Дзержинского'
    }
}

len(json.dumps(data)) # 219 # преобразует в кодировку 'unicode_escape'

# Получим unicode
u_json = json.dumps(data).decode('unicode_escape') 
len(u_json) # 119

# Получим bytes (string 2.7)
str_json = json.dumps(data).decode('unicode_escape').encode('utf-8')
len(str_json) # 139

# в кодировке с алфавитом 64 включает в себя 26+26 + 0-9 и два символа '+/'
# при этом кодирование чисел через django.utils.baseconv.base64 использует символы '-_'
base64.b64encode(str_json) 
'eyJmaXJzdF9uYW1lIjogIlNlcmdleSIsICJsYXN0X25hbWUiOiAiVmxhc292IiwgImFnZSI6ICIyOCIsICJhZGRyZXNzIjogeyJjaXR5IjogItCh0LXRgNC/0YPRhdC+0LIiLCAic3RyZWV0IjogItCU0LfQtdGA0LbQuNC90YHQutC+0LPQviJ9fQ=='
len(base64.b64encode(str_json)) # 188

# Вкодировке b32 размер больше.
len(base64.b64encode(str_json)) # 224
```

#### 2. Проверка достоверности переданных открытых данных.

Нужно передать информацию в открытом json или закодированном виде (но не зашифрованном) и удостовериться, что она от того лица на которое мы рассчитываем (не было man in the middle). Для этого можно использовать hash-функцию, которая на клиенте и на сервере работает одинаково (алгоритм hash-функции предварительно согласуется)

**Алгоритм**:
  1. Клиент перед отправкой делает hash и добавляет его в словарь своих данных (hash_client). 
  1. Сервер при получении делает, то же самое с данными исключая hash_client конечно, и проверяет hash_client и hash_server 


#### 3. передать информацию в зашифрованном виде, чтобы не было возможности её раскрыть.
    1. Шифрование с публичным ключом (ассиметричное) Используется при установке https и обмене сертификатами.
    1. Симетричное шифрование - быстрее чем ассиметричное, используется после установки https. (хорошая связанная статья [https://habr.com/ru/post/258285/](https://habr.com/ru/post/258285/))


### <a name='xpath-usage'>Возможности XPath</a>
1. Можно использовать в браузере сначала получив через `Copy -> XPath`, а затем вставив результат в консоль JavaScript `$x("//")`
1. **TODO**: `На примере errors xml из 1c`
 
 
### <a name='xpath-examples'>Обновление массива пар данных в таблице</a>
Имеем таблицу, она большая - 50 млн строк допустим. Столбцы client_id, phone и др., но интересуют только эти.

К нам обращаются с просьбой обновить телефоны и прилагают .csv файл с 1млн записей. Мы же не будем делать 1млн запросов?


Делаем временную таблицу new_clients_csv, загружаем туда данные. Итерируемся по пачкам - 500 (к примеру)
для них конструируем SQL запросы вида

```sql
 update clients
 set phone = new_csv.phone
 from new_clients_csv new_csv 
 where new_csv.client_id in 500_clients and clients.id=new_csv.client_id
```

CSV - файл упрощение, чаще бывает, что его нужно получить на основе других запросов.


### <a name='vpn-attempts'>Vpn - страдания и радости</a>
VPN - наконец-то в digitalocen стало возможным получить машину IP которой не заблокирован.
Сделал vpn чтобы пользоваться api.telegram.org. Но к моему удивлению vpn все равно не помогал при работе именно с telegram.


Комбинация Мегафон + vpn - работала, а МГТС +  vpn - нет.


Было 3 длительных попытки разобраться почему так получается.
В итоге выяснилось, что обращения были по ipv6, а vpn для них никак не работал. Выяснил это дебага через wireshark. В результате, чтобы работало отключил ipv6 в настройках сетевого подключения через GUI.
 
 
В процессе нахождения решения выяснил:
  - vpn проще поднять через докер я использовал этот [https://github.com/kylemanna/docker-openvpn](https://github.com/kylemanna/docker-openvpn)
  - vpn внутри может быть как с шифрованием, так и без.
  - кроме vpn для анонимизации можно использовать proxy, socks, но это протокольный уровень, а vpn уровень транспортный, поэтому более верный.
  - http-proxy бывают разные, см. тут [https://hidemy.name/ru/proxy-list/](https://hidemy.name/ru/proxy-list/), чтобы быстро понять что к чему.
