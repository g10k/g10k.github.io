---
layout: post
title:  "2019, третья неделя января"
categories: django encryption
---


1. <a href='#my_custom_hash'>Функция хэш с 0</a>
2. <a href='#xor'>Заметки про xor</a>

### <a name='my_custom_hash'>Хэш функция</a>

Попытался сделать хэш from scratch, вот основные "неотесанные" мысли по этому вопросу

**Требования**: 
1. Если строка отличается на 1 символ, хэш должен быть совершенно другим
2. Результаты хэш функции должны быть равномерно распределены

Простейший вариант - это делать последовательно XOR попарно для символов. - Результаты все близки, т.к. это 1 байт
- сделаем результат длины size байт, бьем на блоки s[::size], s[1::size] .. s[size-1::size] и для каждого блока считаем XOR,
тогда при отличие 1 символа, отличается только блок в котороый он входил. А желательно чтобы все блоки отличались - такое явление называется лавинным эффектом.

Понял, чтобы полностью отобразить abcdef в abcdef нужно алфавит сделать кратным степени 2. 2, 4, 8, 16 и т.д.
Изучать глубже нецелесообразно 

Нужно смотреть реализацию уже реализованных алгоритмов. CRC в wiki есть вырезка где сколько циклов ??

Общее что нужно знать: **TODO: ??** 
md5 ненадежен, есть механизм нахождения коллизий,
sha1 (160bit) sha2(256 и др) - более надежные, bcrypt


хэш функции деляется на криптографич (есть требования ). и нет, не криптографические быстрее. 
- md5 изначально позиционировался как крипт., но были найдены уязвимости. Был широко распространен, Используется в более усложнынных схемах md5(md5(plain)+salt) и т.д.

[https://habr.com/ru/post/210760/](Как надо хэшировать пароль)
- нет возможности восстановить по хэшу
- коллизия первого рода: Для Хэша H - не подберешь значение с таким же хэшем
- коллизия второго рода: не найдешь такую пару, что два значения имеют одинаковый хэш.

**где применяются хэши?** 

* "Человек по середине", может получить ключи, подменить ключи и все сообщения сначала расшифровывать и зашифровывать по своему
* Протокол "держась за руки" позволяет обнаружить атаку "человек по середине"

Отмечу общий принцип организации кода в base.py описывается базовый класс (частично реализованный, но большинство методов NotImplemented) исключения и некоторые функции
django.core.serializers.DjangoJSONEncoder добавляет типы данных (Date, Time, DateTime, timedelta, UUID, Decimal, Promise, CallableBool)

В base.Serializer реализован метод serializer внутри которого start_obj/end_obj. Эти вызовы в цикле оборачивают работу с объектом.
Основной принцип, что start_obj - добавляет _current_obj переменную, end_obj - делает её None.
В core.case.base есть `DEFAULT_TIMEOUT = object()` - используется для передачи по умолчанию и сравнения с ним. Называется stub класс - заглушка.

`django.utils:` strconv; datastructs (`ImmutableList, MultiDict, OrderedSet`); `cache` (Vary, add_headers, max_cache_time); encoding (`force_bytes, smart_bytes` нужно еще читать);

### <a name='xor'>Заметки про xor</a>
**XOR** - шифрование самое простое - побитовое сложение 
_Основные моменты_:
1. Попытался сделать xor для ascii символов в python, получаются не abcdef... Алфавит должен быть только из букв
2. Ключ должен выбираться по максимальному расстоянию между буквами
3. Просто взламывается, нужно научиться взламывать его.
